## Erlang编程指南

### 1.Erlang语法基础

Erlang中定义的变量只能被赋值一次。

Erlang中的模式匹配不但确定控制流程，而且还用来绑定变量和解析复杂的数据结构。

#### 1.1 整数

**Integers:**表示整数，可以是正整数和负整数，也可以表示基数不为10的整数。

**Base#Value:**用于表示基数不是10的整数。

#### 1.2 浮点数

**浮点数：**Erlang中浮点数用来代表实数。

#### 1.3 数学运算符

#### 1.4 基元

**基元（atom）：**Erlang中的基元用来表示文字常量，Erlang中的基元和其它语言中的枚举类型作用是一样的。基元的作用相当于Java中的“static final”.

基元由小写字母开始或是由单引号界定。当基元用小写字母开头时，字母、数字、“at”符号（@）、英文句点（.）和下划线（_）都是有效的字符。

#### 1.5 布尔类型

**布尔类型：**Erlang中没有单独表示布尔类型的布尔值或者字符。基于true和false与布尔操作符一起使用，而不是布尔类型，它们用来表示测试的布尔返回值。

#### 1.6 元组

**元组：**用来保存一组数据元素的复合数据类型。其中要求数据元素是Erlang数据类型，但不要求是同一种数据类型。元组使用封闭的花括号来定义{......}，其中的元素由逗号隔开。

**标记：**当一个元组中的第一个元素是一个基元时，称它为标记。使用第一位置的标记是为了区分代码中使用不同元组的不同目的。

#### 1.7 列表

**列表：**列表和元组都是用来存储元素集合的，它们的元素都可以是不同类型的，而且元素数目也可以是任意的。

**列表的格式：**列表使用封闭的方括号[......]来定义，而它们的元素用逗号隔开，列表中的元素和元组中的元素一样不一定是相同的数据类型，它们可以自由混合。

**字符和字符串：**字符由整数表示，字符串由整数列表来表示。字符的整数值可以通过在字母前加上$符得到，Erlang中没有字符串数据类型，在Erlang中字符串是一个ASCII值组成的整数列表，并使用双引号（“”）来表示。因此字符串“Hello World”实际上就是列表[72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100]

**基元和字符串：**它们的处理方式不同，唯一可用作基元的操作是比较操作，而处理字符串的方式却很多种。

**列表的组成和处理：**列表和元组的处理方式不同，元组的处理是提取具体的元素，而列表只要不为空，就可以把一个列表分为头部和尾部。列表的头部是指列表的第一个元素，它的尾部是一个包含所有剩余元素的一个列表，而这个列表可以继续这样分解下去。

**列表函数和操作：**通常用列表来表示对象的集合，它们能够分割成其它的集合，来进一步组合和分析。

#### 1.8 项元比较

**项元比较：**比较运算符的左边和右边。

#### 1.9 变量

**变量：**Erlang中变量必须以大写字母开头，后面的字符可以是大小写字母、整数和下划线。Erlang中只允许给变量单次赋值，

#### 1.10 复杂数据结构

#### 1.11 模式匹配

**模式匹配：**可以用于变量赋值、控制程序的执行流程和从复合数据类型中提取值。

#### 1.12 函数

**函数：**函数的名称是一个基元，一个函数的头包括名字，随后是一对括号，在里面包含多个形式的参数或是没有参数。在Erlang中，函数参数的数量叫做元数，使用箭头（—>）来分割函数头和函数主体。

#### 1.13 模块

**模块：**函数组合在一起构成了模块。文件名称和模块名称必须相同。模块名称可以这样直接命名-module(Name)。

**export:**export指令以Function/Arity的格式，包含了导出函数的一个列表，这些函数是全局性的，这意味着可以从模块的外部调用它们。局部函数只能在模块内部使用。

**模块指令：**每个模块都拥有一个-attribute(Value)格式的属性列表。它们通常放在模块的开始，是由放在属性前面的-符号和结尾的句点来定义。

**-compile(export_all)指令：**在编译阶段导出模块中的所有函数。

**-import(Module,[Function/Arity, ...])：**它允许你从其它模块导入函数然后本地调用它们。



### 2.顺序编程

#### 2.1 条件评估

**条件评估的三种方式：**通过函数的参数进行模式匹配来进行函数的选择执行；case结构；if结构。

##### 2.1.1 case结构

case表达式形式：

```erlang
case conditional-expression of
	Pattern1 -> expression1,expression2,..;
	Pattern2 -> expression1,expression2,..;
	..;
	Patternn -> expression1,expression2,..;
end

```

使用方法：对conditional-expression进行求值，然后和Pattern1，Pattern2，...Patternn,进行匹配，直到第一个模式匹配成功。

##### 2.1.2 变量范围

##### 2.1.3 if结构

if表达式形式：

```erlang
if
	Guard1 ->  expression11, expression12,... ;
	Guard2 ->  expression21, expression22,... ;
	Guard3 ->  expression31, expression32,... ;
	...
	Guard4 ->  expressionn1, expressionn2,... ;
end
```

执行逻辑：表达式Guard1、Guard2...Guardn按次序执行，直到其中的一个结果为true，如果结果是Guardi,就会

执行expressioni1,expressioni2...expressionin; .

#### 2.2 保护元

**保护元：**保护元（guard）是一个额外的限制条件，它应用于函数的case和receive语句中。保护元应该在“->”之前来分隔语句的主体和头部。保护元由where关键字和紧随其后的一个保护元表达式组成。

例子：

```erlang
factorial(N) when N > 0 ->
	N * factorial(N-1);
   factorial(0) -> 1.
```

由模式匹配和保护元一起来唯一确定那些句子被选中执行。

**保护元表达式获取方式：**

> - 约束变量
> - Erlang常量的数据值，比如is_binary、is_atom、is_boolean和is_tuple等
> - 项元比较运算符==、=/=、<、>等
> - 算术运算符组成的算数表达式
> - 布尔表达式
> - 保护元内置函数



#### 2.3 内置函数

##### 2.3.1 内置函数

**内置函数：**内置函数的简写是BIF，内置函数通常使用C语言编写，并集成到虚拟机（VM）中，可用于操作、检查并获取数据，以及与操作系统进行交互。例子：一个数据操作函数的例子是转换一个基元为一个字符串：atom_to_list/1;length/1：返回一个列表的长度。为了保证效率，它在运行时系统里面实现。

**含有内置函数的模块：**Erlang模块、ets模块和lists模块。

##### 2.3.2 元编程

元编程：一个程序在运行时才确定将调用那些函数的特性叫做元编程，也就是程序创建程序并运行。

#### 2.4 递归

递归：

尾递归：

#### 2.5 运行时错误

#### 2.6 处理错误

#### 2.7 模块库



#### 2.8 调试器

### 3.并发编程

#### 3.1 创建进程

**创建进程：**使用内置函数spawn(Module, Function, Arguments)可以生成一个新进程，并对Module中的导出函数Function以列表Arguments作为参数进行求值，

#### 3.2 消息传递

#### 3.3 接收消息

#### 3.4 注册进程

#### 3.5 超时

#### 3.6 性能基准测试

#### 3.7 进程架构

#### 3.8 尾递归和内存泄漏

#### 3.9 面向并发程序的个案研究

#### 3.10 竞争条件、死锁和饥饿进程