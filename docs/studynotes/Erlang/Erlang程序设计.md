## Erlang程序设计

### 1.什么是并发？

#### 1.1 给并发建模

##### 1.1.1 开始模拟

**spawn：** spawn是一个Erlang基本函数，它会创建一个并发进程并返回一个进程标识符。

**spawn的调用方式：**  spawn(ModName, FuncName, [Arg1, Arg2,...,ArgN])。

- ModName：想要执行代码的模块名。
- Function：模块里的函数名。
- [Arg1, Arg2,...,ArgN]：一个列表，包含了想要执行的函数参数。
- Spawn返回的是一个进程标识符（PID，Process IDentifier），可以用来与新创建的进程交互。

#### 1.2 并发的好处

> 性能
>
> 可扩展性
>
> 容错性
>
> 清晰性

### 2.Erlang速揽

#### 2.1 Shell

##### 2.1.1 =操作符

**Erlang单词赋值：** Erlang是一种函数式语言，只能单次赋值，Erlang的变量只能绑定一次，不能重新绑定变量。

**=：** =不是赋值操作符，其实是模式匹配操作符。

##### 2.1.2 变量和原子的语法

**Erlang变量：** Erlang变量都是以大写字母开头，以小写字母开头的是符号常量，它们被称为原子（atom）。

### 3.基本概念

#### 3.1 启动和停止Erlang Shell

#### 3.2 简单的整数运算

**Erlang整数：** Erlang可以用任意长度的整数执行整数运算，在Erlang里，整数运算时精确的，无需担心溢出或无法用特点字长来表示某个整数。

#### 3.3 变量

**变量：** 所有变量必须以大写字母开头，变量只能被一次赋值，Erlang中的变量都是一次性赋值变量。已经被指派一个值的变量称为绑定变量，否则称之为未绑定变量。

**=：** 不是赋值操作符，而是一个**模式匹配** 操作符。=在变量未绑定之前表现类似于赋值。

**可变状态：** 可以修改的内存区域专业术语叫做可变转态。Erlang是一种函数式编程语言，具有不可变状态。

**一次性赋值的优势：** 在Erlang里，变量只不过是对某个值的引用，Erlang的实现方式用指针代表绑定变量，指向一个包含值得存储区，这个值不能被修改。

#### 3.4 浮点数

#### 3.5 原子

**原子：** 在Erlang中，原子被用来表示常量值。原子是全局性的，不需要宏定义或包含文件就能实现。

**原子的格式：** 以小写字母开头，后面接字母、数字、下划线或at(@)符号。原子还可以放在单引号内（‘’），可以用这种引号形式创建以大写字母开头（否则会被解释成变量）的或包含字母、数字以外字符的原子，例如‘Monday’, '+', '*' 或'an atom with space'。甚至可以给无需引号的原子加上引号，因此‘a’和a的意思完全一样。Erlang中单引号和双引号不可以互换使用（某些语言中可以互换使用），Erlang中双引号用于给字符串字面量定界。

#### 3.6 元组

**元组：** 创建元组的方法是用大括号把想要表示的值括起来，并用逗号分隔它们。元组可以嵌套。元组会在声明它们时被主动创建，在不用它们时被销毁。Erlang会使用垃圾收集器来回收所有未使用的内存，这样不用担心内存分配问题。

```erlang
Person = {person, {name, joe}, {height, 1.82}}.
```

#### 3.7 列表

**列表：** 列表被用来存放任意数量的事物，创建列表的方法是用中括号把列表元素括起来，并用逗号分隔它们。列表中的各元素可以是各种类型的。

**列表头和列表尾：** 列表的第一个元素被称为列表头，其它的元素被称为列表尾。

#### 3.8 字符串

**字符串：** Erlang里面没有字符串，要在Erlang中表示字符串，可以选择一个由整数组成的列表或者一个二进制型。当字符串表示为一个整数列表时，列表里的每个元素都代表了一个Unicode代码点(codepoint)。可以用字符串字面量来创建这样一个列表，字符串字面量其实就是用双引号围起来的一串字符。

```erlang
Name = "Hello".
```

"Hello"其实只是一个列表的简写，这个列表包含了代表字符串里各个字符的整数字符代码。

**字符串标记：** Erlang中字符串使用双引号标记。当shell打印某个列表的值时，如果列表内的所有整数都代表可打印字符，它就会将其打印成字符串字面量，否则，打印成列表记法。

```erlang
2>[1,2,3].
[1,2,3]
3>[83,117,114,112,114,105,115,101].
"Surprise"
4>[1,83,117,114,112,114,105,115,101].
[1,83,117,114,112,114,105,115,101]
```

#### 3.9 模式匹配再探

### 4.模块与函数

#### 4.1 模块是存放代码的地方

**模块：** 模块是Erlang存放代码的地方，模块保存在扩展名为.erl的文件中，编译后的模块以.beam为扩展名。

**-module().:**  模块申明，申明里的模块名必须和存放该模块的主文件名相同。

**-export().:** 导出申明。Name/N这种标记方法是指带有N各参数的函数Name，N被称为函数Name的**元数**  。未从模块里导出的函数只能在模块内部调用，已导出的函数相当于面向对象编程里的公共方法，未导出的函数相当于面向对象里的私有方法。

**函数：** 如下所示，函数有两个子句，每个子句以分号隔开，最后的子句以句号加空白结束。每条子句都有一个**头部** 和一个**主体** ，两者用箭头分隔，

```erlang
area({rectangle, Width, Height}) -> Wight * Height;
area({square, Side}) -> Side * Side.
```



#### 4.2 继续购物

#### 4.3 fun:基本的抽象单元

#### 4.4 简单列表处理

#### 4.5 列表推导

#### 4.6 内置函数

#### 4.7 关卡

#### 4.8 case和if表达式

#### 4.9 构建自然顺序的列表































